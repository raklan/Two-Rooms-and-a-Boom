package Engine

import (
	"encoding/json"
	"log"
	"net/http"
	"slices"
	"sync"
	"tworoomsengine/Models"

	"github.com/gorilla/websocket"
)

// Outer key is the room code, inner key is the playerId. Value is the actual connection object
var gamesClients = make(map[string]map[string]*websocket.Conn)

// Mutex to access gamesClients in a thread-safe manner
var gamesClientsMutex = sync.Mutex{}

var upgrader = websocket.Upgrader{
	ReadBufferSize:  32768, // Setting read buffer size to 32 KB
	WriteBufferSize: 32768, // Setting write buffer size to 32 KB
	CheckOrigin: func(r *http.Request) bool {
		return true
	},
}

// HostLobby creates the waiting lobby, joins on behalf of the given player, and upgrades the host into a websocket.
// The lobby (which contains the Room Code used for other people to join) is then passed back into the websocket.
func HostLobby(w http.ResponseWriter, r *http.Request) {
	funcLogPrefix := "==HostLobby=="
	log.Println("Starting hostLobby")
	mapId := r.URL.Query().Get("mapId")
	playerName := r.URL.Query().Get("playerName")

	if mapId == "" || playerName == "" {
		log.Println("Missing mapId or playerName in request")
		http.Error(w, "Missing mapId or playerName in request", http.StatusBadRequest)
		return
	}

	roomCode, err := CreateRoom(mapId) // Assuming Engine.CreateRoom initializes room in DB
	if err != nil {
		LogError(funcLogPrefix, err)
		http.Error(w, "Unable to create room", http.StatusInternalServerError)
		return
	}
	lobbyInfo, playerID, err := JoinRoom(roomCode, playerName)
	if err != nil {
		LogError(funcLogPrefix, err)
		http.Error(w, "Unable to join room", http.StatusInternalServerError)
		return
	}
	log.Printf("%s host has joined room. Upgrading connection to websocket", funcLogPrefix)
	conn, err := upgrader.Upgrade(w, r, nil)
	if err != nil {
		LogError(funcLogPrefix, err)
		http.Error(w, "WebSocket upgrade failed", http.StatusInternalServerError)
		return
	}
	log.Printf("%s host websocket connection established. Sending LobbyInfo and beginning managing connection", funcLogPrefix)
	msg := Models.WebsocketMessage{
		Type: Models.WebsocketMessage_LobbyInfo,
		Data: Models.LobbyInfo{
			PlayerID:  playerID,
			LobbyInfo: lobbyInfo,
		},
	}
	conn.WriteJSON(msg)
	gamesClientsMutex.Lock()
	if _, exists := gamesClients[roomCode]; !exists {
		gamesClients[roomCode] = make(map[string]*websocket.Conn)
	}
	gamesClients[roomCode][playerID] = conn
	gamesClientsMutex.Unlock()

	go manageClient(roomCode, gamesClients[roomCode], playerID, conn)
}

// Given a playerName and roomCode, tries to join that room for the given player. If joining was successul,
// the client's connection is upgraded to a websocket. Once complete, the client receives the lobby info
func HandleJoinLobby(w http.ResponseWriter, r *http.Request) {
	funcLogPrefix := "==HandleJoinLobby=="
	roomCode := r.URL.Query().Get("roomCode")
	playerName := r.URL.Query().Get("playerName")

	if roomCode == "" || playerName == "" {
		http.Error(w, "Please provide roomCode and playerName", http.StatusBadRequest)
		return
	}

	_, playerID, err := JoinRoom(roomCode, playerName)
	if err != nil {
		LogError(funcLogPrefix, err)
		http.Error(w, "Unable to join room", http.StatusNotFound)
		return
	}

	gamesClientsMutex.Lock()
	if _, exists := gamesClients[roomCode]; !exists {
		log.Printf("Lobby {%s} is not being tracked by the server\n", roomCode)
		http.Error(w, "Lobby is not being tracked by server.", http.StatusInternalServerError)
		gamesClientsMutex.Unlock()
		return
	}

	log.Printf("%s player {%s} has joined lobby. Upgrading connection to websocket", funcLogPrefix, playerID)
	conn, err := upgrader.Upgrade(w, r, nil)
	if err != nil {
		LogError(funcLogPrefix, err)
		http.Error(w, "WebSocket upgrade failed", http.StatusInternalServerError)
		gamesClientsMutex.Unlock()
		return
	}

	log.Printf("%s player {%s} websocket connection established. Beginning tracking connection", funcLogPrefix, playerID)

	//Ensure the server is tracking this lobby - if the lobby was created on a previous time the server was running, we'll need to re-add that lobby to the lobby tracker
	if _, exists := gamesClients[roomCode]; !exists {
		gamesClients[roomCode] = make(map[string]*websocket.Conn)
	}

	gamesClients[roomCode][playerID] = conn
	gamesClientsMutex.Unlock()
	go handShake(roomCode, playerID)
}

// Given a roomCode and a playerId (which should have been generated by the backend upon Hosting or Joining that lobby), will attempt to
// reinsert the player into the Lobby. If successful, connection is upgraded to a websocket, then, depending on whether the game has started yet
// or not, either a LobbyInfo or GameState is sent to the player, after which they're added into the regular flow of listening for messages
func HandleRejoinLobby(w http.ResponseWriter, r *http.Request) {
	funcLogPrefix := "==HandleRejoinLobby=="
	log.Printf("%s Received request to rejoin a lobby!", funcLogPrefix)

	roomCode := r.URL.Query().Get("roomCode")
	playerId := r.URL.Query().Get("playerId")

	if roomCode == "" || playerId == "" {
		http.Error(w, "Please send both roomCode and playerId", http.StatusBadRequest)
		return
	}

	lobbyInfo, err := GetLobbyFromFs(roomCode)
	if err != nil {
		LogError(funcLogPrefix, err)
		http.Error(w, "Could not find requested lobby", http.StatusNotFound)
		return
	}

	//Make sure this player has joined the game before
	log.Printf("%s Making sure player {%s} has joined this game before", funcLogPrefix, playerId)
	if !slices.ContainsFunc(lobbyInfo.Players, func(p Models.Player) bool { return p.Id == playerId }) {
		log.Printf("No player with given ID == {%s} found in lobby", playerId)
		http.Error(w, "No player with given ID found in lobby", http.StatusNotFound)
		return
	}

	//Make sure that player does not already have an open connection
	log.Printf("%s Making sure player {%s} does not already have an open connection", funcLogPrefix, playerId)
	gamesClientsMutex.Lock()
	if _, exists := gamesClients[roomCode][playerId]; exists {
		log.Printf("Found already open connection for player with ID == {%s}", playerId)
		http.Error(w, "Found already open connection for player", http.StatusBadRequest)
		gamesClientsMutex.Unlock()
		return
	}
	gamesClientsMutex.Unlock()

	//Now we should know the player is allowed to rejoin. Upgrade to websocket
	log.Printf("%s Player {%s} is allowed to rejoin. Upgrading connection to websocket.", funcLogPrefix, playerId)
	conn, err := upgrader.Upgrade(w, r, nil)
	if err != nil {
		LogError(funcLogPrefix, err)
		http.Error(w, "WebSocket upgrade failed", http.StatusInternalServerError)
		return
	}

	log.Printf("%s Websocket connection established. Checking status of lobby to give accurate first message(s)...", funcLogPrefix)

	//If the game has ended, indicate as such and close connection
	if lobbyInfo.Status == Models.LobbyStatus_Ended {
		log.Printf("%s Game has already ended! Player cannot join!", funcLogPrefix)
		msg := Models.WebsocketMessage{
			Type: Models.WebsocketMessage_Error,
			Data: Models.SocketError{
				Message: "Game has already ended. Cannot rejoin.",
			},
		}
		conn.WriteJSON(msg)
		conn.Close()
		return
	}

	//Send LobbyInfo
	msg := Models.WebsocketMessage{
		Type: Models.WebsocketMessage_LobbyInfo,
		Data: Models.LobbyInfo{
			PlayerID:  playerId,
			LobbyInfo: lobbyInfo,
		},
	}
	conn.WriteJSON(msg)

	//If the game has started, send a GameState
	if lobbyInfo.Status == Models.LobbyStatus_InProgress {
		log.Printf("%s Game has been marked as 'In Progress' - Sending current GameState...", funcLogPrefix)
		gameState, err := GetGameStateFromFs(lobbyInfo.GameStateId)
		if err != nil {
			LogError(funcLogPrefix, err)
			conn.WriteJSON(Models.WebsocketMessage{
				Type: Models.WebsocketMessage_Error,
				Data: Models.SocketError{Message: err.Error()},
			})
		}
		conn.WriteJSON(Models.WebsocketMessage{Type: Models.WebsocketMessage_GameState, Data: gameState})
	}

	log.Printf("%s Player {%s} has been given first message(s). Beginning to track and manage connection", funcLogPrefix, playerId)

	//Store the connection, give the connection its own goroutine, and begin listening for more messages
	gamesClientsMutex.Lock()
	//Ensure the server is tracking this lobby - if the lobby was created on a previous time the server was running, we'll need to re-add that lobby to the lobby tracker
	if _, exists := gamesClients[roomCode]; !exists {
		gamesClients[roomCode] = make(map[string]*websocket.Conn)
	}
	gamesClients[roomCode][playerId] = conn
	room := gamesClients[roomCode]
	gamesClientsMutex.Unlock()

	go manageClient(roomCode, room, playerId, conn)
}

// handShake sends out the lobby info to everyone currently in the room, along with the
// name of the freshly joined player
func handShake(roomCode string, newPlayerId string) {
	funcLogPrefix := "==handShake=="

	log.Printf("%s a new player with Id == {%s} has joined Room {%s}. Beginning handshake", funcLogPrefix, newPlayerId, roomCode)

	gamesClientsMutex.Lock()
	room := gamesClients[roomCode]
	gamesClientsMutex.Unlock()
	jsonLobby, err := GetLobbyFromFs(roomCode)

	msg := Models.WebsocketMessage{
		Type: Models.WebsocketMessage_LobbyInfo,
		Data: Models.LobbyInfo{
			PlayerID:  newPlayerId,
			LobbyInfo: jsonLobby,
		},
	}
	for playerId, conn := range room {
		if err != nil {
			log.Printf("%s error connecting: {%s}", funcLogPrefix, err)
		}
		err := conn.WriteJSON(msg)
		if err != nil {
			LogError(funcLogPrefix, err)
			log.Printf("Error sending handshake, aborting connection of Player {%s}\n", playerId)
			gamesClientsMutex.Lock()
			room[playerId].Close()
			delete(room, playerId)
			gamesClientsMutex.Unlock()
			continue // I don't handle disconnection rn
		}
	}

	log.Printf("%s all players in lobby have been informed of new player joining. Beginning managing connection", funcLogPrefix)

	//Last thing we need to do is start listening for messages from this player
	go manageClient(roomCode, room, newPlayerId, room[newPlayerId])
}

func manageClient(lobbyCode string, room map[string]*websocket.Conn, playerId string, conn *websocket.Conn) {
	funcLogPrefix := "==manageClient=="
	defer socketRecovery(lobbyCode, room, playerId)

	log.Printf("%s Managing Connection for playerId %s and waiting for message", funcLogPrefix, playerId)
	_, msg, err := conn.ReadMessage()
	if err != nil {
		LogError(funcLogPrefix, err)
		log.Printf("%s Error trying to read message from player {%s}! Closing connection and stopping tracking", funcLogPrefix, playerId)
		//Disconnect client by closing connection (if it's not already closed) and stopping tracking of that player's connection
		gamesClientsMutex.Lock()
		if room[playerId] != nil {
			room[playerId].Close()
		}
		delete(room, playerId)
		gamesClientsMutex.Unlock()
		return
	}

	processMessage(lobbyCode, playerId, msg)
}

// This gets called on loop per lobby
func processMessage(roomCode string, playerId string, message []byte) {
	funcLogPrefix := "==processMessage=="

	var msg struct {
		JsonType string          `json:"jsonType"`
		Data     json.RawMessage `json:"data"` //Raw message delays the parsing
	}
	json.Unmarshal(message, &msg)

	gamesClientsMutex.Lock()
	room := gamesClients[roomCode]
	gamesClientsMutex.Unlock()

	log.Printf("%s message received from PlayerId {%s} of type '%s' - trying to handle...", funcLogPrefix, playerId, msg.JsonType)

	switch msg.JsonType {
	case "startGame":
		log.Printf("%s Received request to start game", funcLogPrefix)
		config := Models.GameConfig{}
		if err := json.Unmarshal(msg.Data, &config); err != nil {
			log.Printf("error decoding startGame config: %s", err)
			socketError := Models.WebsocketMessage{
				Type: Models.WebsocketMessage_Error,
				Data: Models.SocketError{
					Message: err.Error(),
				},
			}
			room[playerId].WriteJSON(socketError)
			break
		}

		game, err := GetInitialGameState(roomCode, config)
		if err != nil {
			LogError(funcLogPrefix, err)
			log.Printf("%s ERROR: GAME NOT STARTED, ABORTING...", funcLogPrefix)
			break
		}

		sendMessageToAllPlayers(room, Models.WebsocketMessage{Type: Models.WebsocketMessage_GameState, Data: game})
	case "endGame":
		err := EndGame(roomCode, playerId)
		if err != nil {
			LogError(funcLogPrefix, err)
			log.Printf("%s ERROR: Trying to end game, aborting...", funcLogPrefix)
			return
		}
		cleanUpRoom(room, roomCode)
	// case "submitAction":
	// 	var action struct {
	// 		GameId string                  `json:"gameId"`
	// 		Action Actions.SubmittedAction `json:"action"`
	// 	}
	// 	if err := json.Unmarshal(msg.Data, &action); err != nil {
	// 		log.Printf("%s error decoding submitAction: {%s}", funcLogPrefix, err)
	// 		socketError := Models.WebsocketMessage{
	// 			Type: Models.WebsocketMessage_Error,
	// 			Data: Models.SocketError{
	// 				Message: err.Error(),
	// 			},
	// 		}
	// 		room[playerId].WriteJSON(socketError)
	// 		break
	// 	}

	// 	//Supply PlayerId with the Id of the player belonging to this connection
	// 	action.Action.PlayerId = playerId

	// 	messageList, err := SubmitAction(action.GameId, action.Action)
	// 	if err != nil {
	// 		LogError(funcLogPrefix, err)
	// 		socketError := Models.WebsocketMessage{
	// 			Type: Models.WebsocketMessage_Error,
	// 			Data: Models.SocketError{
	// 				Message: err.Error(),
	// 			},
	// 		}
	// 		room[playerId].WriteJSON(socketError)
	// 		break
	// 	}

	// 	for _, messageToSend := range messageList {
	// 		if messageToSend.ShouldBroadcast {
	// 			sendMessageToAllPlayers(room, messageToSend.Message)
	// 		} else {
	// 			room[playerId].WriteJSON(messageToSend.Message)
	// 		}
	// 	}

	// 	if slices.ContainsFunc(messageList, func(li Models.WebsocketMessageListItem) bool {
	// 		return li.Message.Type == Models.WebsocketMessage_GameOver
	// 	}) {
	// 		MarkLobbyAsEnded(roomCode)
	// 		cleanUpRoom(room, roomCode)
	// 	}
	case "leaveLobby":
		updatedLobby, err := endPlayerConnection(roomCode, playerId, room)

		if err != nil {
			LogError(funcLogPrefix, err)
			socketError := Models.WebsocketMessage{
				Type: Models.WebsocketMessage_Error,
				Data: Models.SocketError{
					Message: err.Error(),
				},
			}
			room[playerId].WriteJSON(socketError)
			break
		}

		sendMessageToAllPlayers(room, Models.WebsocketMessage{Type: Models.WebsocketMessage_LobbyInfo, Data: Models.LobbyInfo{PlayerID: "", LobbyInfo: updatedLobby}})
	case "kickPlayer":
		var action struct {
			PlayerToKick string `json:"playerToKick"`
		}
		if err := json.Unmarshal(msg.Data, &action); err != nil {
			log.Printf("%s Error trying to unmarshal kick request into struct with field 'playerToKick' ... Please ensure field exists in Data", funcLogPrefix)
			socketError := Models.WebsocketMessage{
				Type: Models.WebsocketMessage_Error,
				Data: Models.SocketError{
					Message: "Message is malformed. Please ensure field 'playerToKick' is found in message object's 'Data' field!",
				},
			}
			room[playerId].WriteJSON(socketError)
			break
		}

		dbLobby, err := GetLobbyFromFs(roomCode)

		if err != nil {
			log.Printf("%s Error trying to find lobby: %s", funcLogPrefix, err)
			socketError := Models.WebsocketMessage{
				Type: Models.WebsocketMessage_Error,
				Data: Models.SocketError{
					Message: "Could not find lobby. Something has gone terribly wrong",
				},
			}
			room[playerId].WriteJSON(socketError)
			break
		}

		if dbLobby.Host.Id != playerId {
			socketError := Models.WebsocketMessage{
				Type: Models.WebsocketMessage_Error,
				Data: Models.SocketError{
					Message: "Player submitting kick request is not the host of the lobby!",
				},
			}
			room[playerId].WriteJSON(socketError)
			break
		}

		updatedLobby, err := endPlayerConnection(roomCode, action.PlayerToKick, room)

		if err != nil {
			LogError(funcLogPrefix, err)
			socketError := Models.WebsocketMessage{
				Type: Models.WebsocketMessage_Error,
				Data: Models.SocketError{
					Message: err.Error(),
				},
			}
			room[playerId].WriteJSON(socketError)
			break
		}

		sendMessageToAllPlayers(room, Models.WebsocketMessage{Type: Models.WebsocketMessage_LobbyInfo, Data: Models.LobbyInfo{PlayerID: "", LobbyInfo: updatedLobby}})
	case "disconnect":
		log.Printf("%s Player %s is requesting a disconnect!", funcLogPrefix, playerId)
		conn := room[playerId]
		msg := Models.WebsocketMessage{
			Type: Models.WebsocketMessage_Close,
			Data: Models.SocketClose{
				Message: "Request acknowledged, closing connection",
			},
		}

		conn.WriteJSON(msg)
		log.Printf("%s Close message has been sent, closing connection", funcLogPrefix)
		conn.Close()
		delete(room, playerId)
		log.Printf("%s Connection closed and server has stopped tracking websocket connection", funcLogPrefix)
		return //Return so we don't go back into manageClient
	default:
		log.Printf("%s Unknown type sent, ignoring the following message: %s", funcLogPrefix, msg)
	}

	//Listen for the next message from this client. Not using `go manageClient(...)` because this is already happening in a goroutine
	manageClient(roomCode, room, playerId, room[playerId])
}

func endPlayerConnection(roomCode string, playerId string, room map[string]*websocket.Conn) (Models.Lobby, error) {
	funcLogPrefix := "==endPlayerConnection=="
	//Tell the engine to remove the player from the DB copy of the lobby
	updatedLobby, err := LeaveRoom(roomCode, playerId)
	if err != nil {
		LogError(funcLogPrefix, err)
		return Models.Lobby{}, err
	}

	//If the removed client has a currently open connection, tell that the client that the connection is closing, then close connection
	if conn, exists := room[playerId]; exists {
		msg := Models.WebsocketMessage{
			Type: Models.WebsocketMessage_Close,
			Data: Models.SocketClose{
				Message: "Player has been removed from Lobby. Closing connection",
			},
		}
		conn.WriteJSON(msg)
		conn.Close()
		//Remove connection from lobby map so we don't try to send them any more messages
		gamesClientsMutex.Lock()
		delete(room, playerId)
		gamesClientsMutex.Unlock()
	}

	return updatedLobby, nil
}

func cleanUpRoom(room map[string]*websocket.Conn, roomCode string) {
	funcLogPrefix := "==cleanUpRoom=="
	log.Printf("%s cleaning up Room {%s}", funcLogPrefix, roomCode)
	closeMessage := Models.WebsocketMessage{
		Type: Models.WebsocketMessage_Close,
		Data: Models.SocketClose{
			Message: "Game has ended. Closing connection",
		},
	}

	gamesClientsMutex.Lock()
	//Send the messages to every player and stop tracking their connection
	for playerId, conn := range room {
		log.Printf("%s stopping tracking and closing connection for PlayerId %s", funcLogPrefix, playerId)
		err := conn.WriteJSON(closeMessage)
		if err != nil {
			log.Printf("Error sending Close Message to %s. Aborting message, but closing connection anyways", playerId)
		}
		conn.Close()
		delete(room, playerId)
	}

	//Stop tracking the room
	log.Printf("%s stopping tracking of Room {%s}", funcLogPrefix, roomCode)
	delete(gamesClients, roomCode)
	gamesClientsMutex.Unlock()
	log.Printf("%s room successfully cleaned up", funcLogPrefix)
}

func sendMessageToAllPlayers(room map[string]*websocket.Conn, message Models.WebsocketMessage) {
	funcLogPrefix := "==sendMessageToAllPlayers=="

	if message.Type == "" {
		log.Printf("%s WARNING: Websocket message being sent has no Type set! Frontend will likely not know how to handle the message!", funcLogPrefix)
	}

	for playerId, conn := range room {
		err := conn.WriteJSON(message)
		if err != nil {
			log.Printf("%s Error sending message, skipping meesage to PlayerId {%s}", funcLogPrefix, playerId)
			continue
		}
	}
}

// Defer this function whenever you try to read from a socket. If ReadMessage panics, this will kick in. Note: This must be set up (deferred) **BEFORE** calling ReadMessage
func socketRecovery(roomCode string, room map[string]*websocket.Conn, playerId string) {
	funcLogPrefix := "==socketRecovery=="
	if r := recover(); r != nil {
		log.Printf("%s Something went wrong trying to manage the connection of Player, likely due to an unexpected closing of the Websocket connection for PlayerId {%s}\n\t Error is: %s", funcLogPrefix, playerId, r)
		//Disconnect client by closing connection (if it's not already closed) and stopping tracking of their connection
		gamesClientsMutex.Lock()

		if room[playerId] != nil {
			room[playerId].Close()
		}
		delete(room, playerId)
		if len(room) == 0 {
			delete(gamesClients, roomCode)
		}
		gamesClientsMutex.Unlock()
	}
}
